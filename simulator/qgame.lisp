;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; qgame.lisp;; c) 1999-2004, Lee Spector (lspector@hampshire.edu);; version 1.20031226 (major version number.yyyymmdd);; version history below#|VERSION HISTORYVersion 1 was adapted from "qc-sim", a simulator that only allowed "measureand stop or continue" measurements, in late November 1999. The slowdown fromnon-branching (measure and stop/continue) simulator appears to be ~30% for a2-intermediate-measurement 2-bit and-or algorithm (one of the examples below).May 30, 2000: Added more explicit 'long float' declarations to minimizeroundoff errors under Allegro. NOTE: It is also necessary to ensure thatfloat args to gates are longs to avoid these roundoff errors.November 13, 2000: Fixed bug in calculation of prior probabilities upon branching (was multiplying by parent's prior probability, which shouldn'tbe done). Impact should only have been for calculating expected number of oraclecalls.July 24, 2002: Cosmetic improvements for distribution.December 26, 2003: Fixed documentation of LIMITED-ORACLE|#; for maximum reasonably safe speed(eval-when (compile)  (declaim (optimize (speed 3) (safety 1) (space 0) (debug 0))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; class definition for a quantum system(defclass quantum-system ()  (;; the number of qubits in the system   (number-of-qubits :accessor number-of-qubits :initarg :number-of-qubits)   ;; an array of amplitudes   (amplitudes :accessor amplitudes :initarg :amplitudes :initform nil)   ;; the probability for having reached this system in the first place   (prior-probability :accessor prior-probability :initarg :prior-probability                       :initform 1)   ;; the number of oracle calls that have been made in the history of this system   (oracle-count :accessor oracle-count :initarg :oracle-count :initform 0)   ;; a list of measurements and their results in the history of this system   (measurement-history :accessor measurement-history :initarg :measurement-history                        :initform nil)   ;; a list of all instructions executed in the history of this system   (instruction-history :accessor instruction-history :initarg :instruction-history                        :initform nil)   ;; the program yet to be executed by this system (if it hasn't yet terminated)   (program :accessor program :initarg :program :initform nil)   ;; the following are just for convenience   (qubit-numbers :accessor qubit-numbers)         ;; all valid qubit indices   (amplitude-address :accessor amplitude-address) ;; used for looping through qubits   ))(defmethod initialize-instance :after ((qsys quantum-system) &rest args)  "An initializer for quantum systems."  (declare (ignore args))  (let ((num-qubits (number-of-qubits qsys)))    ;; if there are no amplitudes yet then initialize to |00...0>    (unless (amplitudes qsys)      (setf (amplitudes qsys)            (let ((amps (make-array (expt 2 num-qubits)                                     :initial-element 0.0L0)))              (setf (aref amps 0) 1.0L0) ;; start in zero state              amps)))    ;; initilize list of valid qubit indices    (setf (qubit-numbers qsys)          (let ((all nil))            (dotimes (i num-qubits) (push i all))            (reverse all)))    ;; initialize address register for amplitudes    (setf (amplitude-address qsys)          (make-array num-qubits :initial-element 0))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; quantum computer manipulation utilities(defun set-address-components (qsys count qubits)  "Sets (amplitude-address qsys) to refer to a particular amplitude, asindicated by the bits in the integer count."  (dotimes (i (length qubits))    (setf (aref (amplitude-address qsys) (nth i qubits))          (if (logbitp i count) 1 0))))               (defun map-qubit-combinations (qsys function qubits)  "Calls function once for each of the 1/0 combinations of the providedqubits, with the right-most qubit varying the fastest."  (setq qubits (reverse qubits))  (let ((number-of-iterations (expt 2 (length qubits))))    (dotimes (i number-of-iterations)      (set-address-components qsys i qubits)      (funcall function))))(defun get-addressed-amplitude (qsys)  "Returns the amplitude currently addressed by (amplitude-address qsys)"  (let ((numerical-address 0))    (dotimes (i (number-of-qubits qsys))      (unless (zerop (aref (amplitude-address qsys) i))        (incf numerical-address (expt 2 i))))    (aref (amplitudes qsys) numerical-address)))(defun set-addressed-amplitude (qsys new-value)  "Sets the amplitude currently addressed by (amplitude-address qsys) to new-value."  (let ((numerical-address 0))    (dotimes (i (number-of-qubits qsys))      (unless (zerop (aref (amplitude-address qsys) i))        (incf numerical-address (expt 2 i))))    (setf (aref (amplitudes qsys) numerical-address) new-value)))(defun matrix-multiply (matrix column)  "Multiplies the given square matrix by the given column (assumedto be the right length) and returns the resulting column."  (let ((matrix-size (car (array-dimensions matrix)))        (result nil))    (dotimes (i matrix-size)      (push (let ((element 0))              (dotimes (j matrix-size)                (incf element (* (aref matrix i j) (nth j column))))              element)            result))    (reverse result)))(defun extract-column (qsys qubits-to-vary)  "Returns a column from the amplitudes obtained by varying the listedqubits, with the right-most qubit varying the fastest."  (let ((col nil))    (map-qubit-combinations      qsys     #'(lambda ()          (push (get-addressed-amplitude qsys) col))     qubits-to-vary)    (reverse col)))(defun install-column (qsys column qubits-to-vary)  "Installs the given column in the amplitude positions obtained byvarying the listed qubits, with the right-most qubit varying the fastest."  (map-qubit-combinations    qsys   #'(lambda ()        (set-addressed-amplitude qsys (car column))       (setq column (cdr column)))   qubits-to-vary))(defun apply-operator (qsys operator qubits)  "Applies the given matrix-form operator to the given qubits."  (map-qubit-combinations   qsys   #'(lambda ()       ;(format t "~%address:~A" (amplitude-address qsys))       (let* ((pre-column (extract-column qsys qubits))              (post-column (matrix-multiply operator pre-column)))         (install-column qsys post-column qubits)))   (set-difference (qubit-numbers qsys) qubits))  qsys)(defun qc-output-probabilities (qsys qubits)  "Returns a list of the probabilities for all combinations for thegiven qubits, in binary order with the rightmost qubit varying fastest."  (let ((probabilities nil)        (other-qubits (set-difference (qubit-numbers qsys) qubits)))    (map-qubit-combinations     qsys     #'(lambda ()         (push (let ((probability 0))                 (map-qubit-combinations                  qsys                  #'(lambda ()                      (incf probability                             (expt (abs (get-addressed-amplitude qsys)) 2)))                  other-qubits)                 probability)               probabilities))     qubits)    (reverse probabilities)))(defun multi-qsys-output-probabilities (qsys-list qubits)  "Returns a list of the probabilities for all combinations for thegiven qubits, in binary order with the rightmost qubit varying fastest.This function takes a LIST of quantum systems as input and sums theresults across all systems."  (let ((probabilities         (mapcar #'(lambda (qsys)                      (qc-output-probabilities qsys qubits))                 qsys-list)))    (labels ((add-lists (l1 l2)               (if (null l1)                  nil                 (cons (+ (first l1) (first l2))                       (add-lists (rest l1) (rest l2))))))      (reduce #'add-lists probabilities))))(defun expected-oracles (qsys-list)  "Returns the expected number of oracle calls for the givenset of quantum systems."  (reduce #'+          (mapcar #'(lambda (qsys)                      (* (prior-probability qsys)                         (oracle-count qsys)))                  qsys-list)))    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; oracle gates(defun binary-operator-matrix (tt-right-column)  "Returns a matrix operator for a binary function with thegiven tt-right-column as the right column of its truth table."  (let* ((column-length (length tt-right-column))         (operator-size (* 2 column-length))         (matrix (make-array (list operator-size operator-size)                             :initial-element 0)))    (dotimes (i column-length)      (let ((offset (* i 2)))        (if (zerop (nth i tt-right-column))          (setf (aref matrix offset offset) 1                (aref matrix (1+ offset) (1+ offset)) 1)          (setf (aref matrix offset (1+ offset)) 1                (aref matrix (1+ offset) offset) 1))))    matrix))(defun oracle (qsys tt-right-column &rest qubits)  "Applies the oracle operator built from tt-right-column, whichis the right column of the corresponding truth table."  (incf (oracle-count qsys))  (apply-operator   qsys   (binary-operator-matrix tt-right-column)   qubits))(defun limited-oracle (qsys max-calls tt-right-column &rest qubits)  "If (oracle-count qsys) is less than max-calls then this applies the oracle operator built from tt-right-column, which is the right column of the corresponding truth table. Otherwise this does nothing."  (if (< (oracle-count qsys) max-calls)    (progn (incf (oracle-count qsys))           (apply-operator            qsys            (binary-operator-matrix tt-right-column)            qubits))    qsys));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; other quantum gates(defun qnot (qsys q)  "Quantum NOT gate"  (apply-operator qsys                   #2A((0 1)                      (1 0))                  (list q)))  (defun cnot (qsys q1 q2)  "Quantum Controlled NOT gate"  (apply-operator qsys                   #2A((1 0 0 0)                      (0 1 0 0)                      (0 0 0 1)                      (0 0 1 0))                  (list q1 q2)))(defun srn (qsys q)  "Quantum Square-Root-of-NOT gate"  (apply-operator   qsys    (make-array '(2 2)               :initial-contents                (list (list (/ 1 (sqrt 2.0L0))  (- (/ 1 (sqrt 2.0L0))))                     (list (/ 1 (sqrt 2.0L0))  (/ 1 (sqrt 2.0L0)))                     ))   (list q)))(defun nand (qsys q1 q2 q3)   "Quantum NAND gate"  (apply-operator   qsys    (binary-operator-matrix '(1 1 1 0))   (list q1 q2 q3)))(defun hadamard (qsys q)  "Quantum Hadamard gate"  (apply-operator   qsys    (make-array '(2 2)              :initial-contents               (list (list (/ 1 (sqrt 2.0L0))  (/ 1 (sqrt 2.0L0)))                    (list (/ 1 (sqrt 2.0L0))  (- (/ 1 (sqrt 2.0L0))))                    ))   (list q)))(defun u-theta (qsys q theta)  "Quantum U-theta (rotation) gate"  (apply-operator   qsys    (make-array '(2 2)               :initial-contents                (list (list (cos theta)  (sin theta))                     (list (- (sin theta))  (cos theta))                     ))   (list q)))(defun cphase-old (qsys q1 q2 alpha)  "Quantum conditional phase gate, OLD VERSION"  (apply-operator   qsys    (make-array '(4 4)               :initial-contents                (list (list 1 0 0 0)                     (list 0 1 0 0)                     (list 0 0 0 (exp (* (sqrt -1.0L0) alpha)))                     (list 0 0 (exp (- (* (sqrt -1.0L0) alpha))) 0)                     ))   (list q1 q2)))(defun cphase (qsys q1 q2 alpha)  "Quantum conditional phase gate"  (apply-operator   qsys    (make-array '(4 4)               :initial-contents                (list (list 1 0 0 0)                     (list 0 1 0 0)                     (list 0 0 1 0)                     (list 0 0 0 (exp (* (sqrt -1.0L0) alpha)))                     ))   (list q1 q2)));; U(2) =  U(phi) * R(theta) * U(psi) * exp(i alpha)I;; where  U(a) = e^(-ia) 0;;               0       e^(ia);; and    R(a) = cos(a) sin(-a);;               sin(a) cos(a);; This is all pre-multiplied in the following code(defun u2 (qsys q phi theta psi alpha)  "Quantum U2 gate, implemented as:        e^(i(-phi-psi+alpha))*cos(theta)  e^(i(-phi+psi+alpha))*sin(-theta)        e^(i(phi-psi+alpha))*sin(theta)   e^(i(phi+psi+alpha))*cos(theta)    "  (apply-operator   qsys    (let ((i (sqrt -1.0L0)))     (make-array      '(2 2)      :initial-contents       (list (list (* (exp (* i (+ (- phi) (- psi) alpha))) (cos theta))                  (* (exp (* i (+ (- phi) psi alpha))) (sin (- theta))))            (list (* (exp (* i (+ phi (- psi) alpha))) (sin theta))                  (* (exp (* i (+ phi psi alpha))) (cos theta)))            )))   (list q)))(defun swap (qsys q1 q2)  "A quantum gate that swaps the amplitudes for the two specified qubits."  (apply-operator   qsys   (make-array '(4 4)               :initial-contents                (list (list 1 0 0 0)                     (list 0 0 1 0)                     (list 0 1 0 0)                     (list 0 0 0 1)                     ))   (list q1 q2)))(defun printamps (qsys)  "For use in quantum programs; causes the amplitudes of the executing quantum system to be printed."  (print (amplitudes qsys))  qsys)(defun insp (qsys)  "For use in quantum programs; causes the inspector to be invoked on the executing quantum system."  (inspect qsys)  qsys);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; utilities for measurement and branching(defun end (qsys)   "Marks the end of a measurement branch; has no effect when usedin a quantum program in any other context."   qsys)(defun distance-to-next-unmatched-end (list &optional                                             (num-measures 0) (num-ends 0)                                             (distance-so-far 0))  "Returns 0 if there is no unmatched (end) in list; otherwise returnsthe number of instructions to the next unmatched (end) (counting the (end))."  (if (null list)     0    (if (eq (caar list) 'end)      (if (zerop num-measures)        (+ 1 distance-so-far)        (if (oddp num-ends) ;; then this one closes a measure          (distance-to-next-unmatched-end (cdr list)                                          (- num-measures 1) (- num-ends 1)                                          (+ 1 distance-so-far))          (distance-to-next-unmatched-end (cdr list)                                          num-measures (+ num-ends 1)                                           (+ 1 distance-so-far))))      (if (eq (caar list) 'measure)        (distance-to-next-unmatched-end (cdr list)                                        (+ num-measures 1) num-ends                                        (+ 1 distance-so-far))        (distance-to-next-unmatched-end (cdr list)                                        num-measures num-ends                                        (+ 1 distance-so-far))))))(defun without-if-branch (program)  "Assuming that a MEASURE form has just been removed from the givenprogram, returns the remainder of the program without the IF (measure-1)branch."  (let* ((distance-to-first-unmatched-end           (distance-to-next-unmatched-end program))         (distance-from-first-to-second-unmatched-end          (distance-to-next-unmatched-end           (nthcdr distance-to-first-unmatched-end program))))    (if (zerop distance-to-first-unmatched-end)      ;; it's all the if part      nil      ;; there is some else part      (if (zerop distance-from-first-to-second-unmatched-end)        ;; the else never ends        (subseq program distance-to-first-unmatched-end)        ;; the else does end        (append (subseq program                         distance-to-first-unmatched-end                        (+ distance-to-first-unmatched-end                           distance-from-first-to-second-unmatched-end                           -1))                (subseq program (+ distance-to-first-unmatched-end                                   distance-from-first-to-second-unmatched-end                                   )))))))(defun without-else-branch (program)  "Assuming that a MEASURE form has just been removed from the givenprogram, returns the remainder of the program without the ELSE (measure-0)branch."  (let* ((distance-to-first-unmatched-end           (distance-to-next-unmatched-end program))         (distance-from-first-to-second-unmatched-end          (distance-to-next-unmatched-end           (nthcdr distance-to-first-unmatched-end program))))    (if (zerop distance-to-first-unmatched-end)      ;; it's all the if part      program      ;; there is some else part      (if (zerop distance-from-first-to-second-unmatched-end)        ;; the else never ends        (subseq program 0 (- distance-to-first-unmatched-end 1))        ;; the else does end        (append (subseq program 0 (- distance-to-first-unmatched-end 1))                (subseq program (+ distance-to-first-unmatched-end                                   distance-from-first-to-second-unmatched-end                                   )))))))        (defun force-to (measured-value qubit qsys)  "Collapses a quantum system to the provided measured-value for the providedqubit."  (map-qubit-combinations   qsys   #'(lambda ()       (let* ((pre-column (extract-column qsys (list qubit)))              (new-column (case measured-value                            (0 (list (first pre-column) 0))                            (1 (list 0 (second pre-column))))))         (install-column qsys new-column (list qubit))))   (remove qubit (qubit-numbers qsys)))  qsys)